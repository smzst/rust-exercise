# rust-exercise

* `String::new()` の `::` は new が String 型の関連関数であることを表している。スタティックメソッドと呼ぶ言語もある
* `read_line()` の引数には、格納する文字列を渡す
* `parse()` は何にパースするか明示する必要がある場合が多い
    * guess: u32 としても、parse::<u32>() としてもよい
    ```rust
    let guess: u32 = guess.trim().parse::<u32>().expect("")
    ```
* トレイトに実装されてるメソッドがある場合はトレイトのインポートが必要
    ```rust
    use rand::Rng; // これ
    let secret_number = rand::thread_rng().gen_range(1, 11);
    ```
* 定数 `const`: 可変にはできない。型注釈は必ず必要。グローバルスコープである。定数式しかセットできない（関数呼び出しの結果や実行時に評価される値はだめ）
    * グローバルスコープとのことで、あるスコープの中では定数ではある値に関しては使わないでおいた方がいいかもしれない
    * でも、「定義されたスコープ内でずっと有効です」と書かれていてどっちなんだろう（3 章）
* シャドーイングは可変にするのとは違う。let を使うことは実効的には新しい変数を生成していることになる。変数の名前が同じなだけで別の不変な値になっている
    ```rust
    // 代入
    let x = 5;
    x = 6;
    
    // シャドーイング
    let x = 5;
    let x = x + 1;
    ```
* 整数型には、8, 16, 32, 64 bit と OS のアーキテクチャ依存の size がある（それぞれ i: 正負, u: 正 がつく）
    * `i8` なら、-128 ~ 127 まで、`u8` なら 0 ~ 255 まで
* どの整数型・浮動小数点型を使うべきか？
    * 整数型の基準は `i32`（64bit system でもこれが最速）
    * `isize`, `usize` を使うのはなんらかのコレクションにアクセスするとき
    * 浮動小数点型の基準は `f64`（`f32` とほぼ同じスピードで精度が高い）
* 配列型は固定長であり、一度宣言されたら伸びも縮みもしない。ベクタ型は伸縮させることができる
    * 配列は、ヒープよりもスタックにデータのメモリを確保したいとき、または常に固定長の要素があることを確認したいときに有効（たとえば 1 年の月の名前）
    * どちらを使うべきか確証が持てないときはベクタ型を使うべき
* 式は文末に `;` を付けない。つけると文扱いになる
    * 式は評価されて値を返すもの、文は値を返さないもの 
